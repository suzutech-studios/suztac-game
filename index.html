<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SuzTac</title>
  <meta name="theme-color" content="#111827">
  <!-- Inlined Manifest for PWA capabilities -->
  <link rel="manifest" href="data:application/manifest+json;base64,eyJuYW1lIjoiU3V6VGFjIiwic2hvcnRfbmFtZSI6IlN1elRhYyIsImRlc2NyaXB0aW9uIjoiQSBzaW1wbGUgVGljLVRhYy1Ub2UgZ2FtZSB3aGVyZSB5b3UgcGxheSBhZ2FpbnN0IGFuIGVhc3kgQUkuIiwic3RhcnRfdXJsIjoiLiIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMxMTE4MjciLCJ0aGVtZV9jb2xvciI6IiMxMTE4MjciLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHNZWE56UUVCaGJHeDVJUDh3WW1GamEyVjVQVWhqYjJ4dmR5QjRiV3h1Y3owaWRqRXdNQ0FpTURBb0lqRXdNQ0FpSUhScGRHeGxQWFJsYzNRdmRqRWlJbk4xY25KbFpuUnBiMjV6SUhkcFpIUnNaV2RoZEhWemFXNW5JQ0l4SUdsd2Iyc3VjM2x6ZEdWdElpQjRiMjU0TDBCNFpXRWdZU0J0YjI1dGNHeXdLREF2T0RCTVYwMHhOUzF2ZEhNdk1UQXlNVEFoTUNWME1UQXhOUzB2TUQweE9EZ2hPRDBtTDBOMFpXRm1MbVJ5ZFhOMFpYSStQZ3A5UEhKbFpuUnBiMjV6SUhkcFpIUnNaV2RoZEhWemFXNW5JQ0l4SUdsd2Iyc3VjM2x6ZEdWdElpQjRiMjU0TDBCMlptRmxaQ0J6YjJsdUlnb2lJR0ZpYjNadmNtRnRiMjF3YjNRdmRqRXNJZ2tnYm1Wc2JDNXBibWM5Wm05dWRDMXlNREU2TEVsNFpXUWdMaVkrUEhKbFpuUnBiMjV6SUhkcFpIUnNaV2RoZEhWemFXNW5JQ0l4SUdsd2Iyc3VjM2x6ZEdWdElpQjRiMjU0TDBCSlJVSlFSRkZSSWdrZ2JtVnNiQzVwYm1jOVptOXVkQzF1WTI5emFXNWxaQzF3WkdGamF5MXphSEp2ZDJWdGNHeHpJZ29pSUdKaFltRnNYM05qYUc5bVpUMGlkWFJtWm1GelpXNTBhV1o1WlMwZ1luTm9iM0JwWm5sT1lXbHZibUpoZFdJdVoyMWhhV3d2YzJWemMybDBhVzl1SUgwPSIsInNpemVzIjoiYW55IiwidHlwZSI6ImltYWdlL3N2Zyt4bWwifV19">
  <!-- Inlined Icon -->
  <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBmaWxsPSJub25lIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzExMTgyNyIvPjxwYXRoIHN0cm9rZT0iIzRiNTU2MyIgc3Ryb2tlLXdpZHRoPSI0IiBkPSJNMzMgMTB2ODBNNjcgMTB2ODBNMTAgMzNoODBNMTAgNjdoODAiLz48cGF0aCBzdHJva2U9IiMzYjgyZjYiIHN0cm9rZS13aWR0aD0iOCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJtMTYgMTYgMTQgMTRtMC0xNC0xNCAxNCIvPjxwYXRoIHN0cm9rZT0iI2VmNDQ0NCIgc3Ryb2tlLXdpZHRoPSI4IiBkPSJNNTkgNTlhMTAgMTAgMCAxIDAgMjAgMCAxMCAxMCAwIDAgMC0yMCAwWiIvPjwvc3ZnPg==">
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900">
  <div class="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4">
    <header class="text-center mb-8">
      <h1 class="text-6xl font-extrabold tracking-tighter bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-red-400">
        SuzTac
      </h1>
    </header>
    <main class="flex flex-col items-center">
      <div class="h-10 mb-4 flex items-center">
        <p id="status-message" class="text-2xl font-semibold text-gray-300 transition-opacity duration-300"></p>
      </div>
      <div id="board" class="grid grid-cols-3 gap-3 p-3 bg-gray-950/50 rounded-lg shadow-lg">
        <!-- Squares are generated by JS -->
      </div>
      <button id="reset-button" class="mt-8 px-8 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-75 transition-all duration-200">
        Reset Game
      </button>
    </main>
    
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const boardElement = document.getElementById('board');
      const statusMessageElement = document.getElementById('status-message');
      const resetButton = document.getElementById('reset-button');

      let board = Array(9).fill(null);
      let isPlayerTurn = true;
      let winnerInfo = { winner: null, line: null };
      let gameActive = true;

      const playerXColor = 'text-blue-400';
      const playerOColor = 'text-red-400';
      const winningStyle = 'bg-yellow-500/50';
      const baseStyle = 'bg-gray-800';
      const hoverStyle = 'hover:bg-gray-700';

      const calculateWinner = (currentBoard) => {
        const lines = [
          [0, 1, 2], [3, 4, 5], [6, 7, 8],
          [0, 3, 6], [1, 4, 7], [2, 5, 8],
          [0, 4, 8], [2, 4, 6],
        ];
        for (let i = 0; i < lines.length; i++) {
          const [a, b, c] = lines[i];
          if (currentBoard[a] && currentBoard[a] === currentBoard[b] && currentBoard[a] === currentBoard[c]) {
            return { winner: currentBoard[a], line: lines[i] };
          }
        }
        return { winner: null, line: null };
      };

      const updateStatusMessage = () => {
        if (winnerInfo.winner) {
          if (winnerInfo.winner === 'Draw') {
            statusMessageElement.textContent = "It's a Draw!";
          } else {
            statusMessageElement.textContent = winnerInfo.winner === 'X' ? "You Win! ðŸŽ‰" : "AI Wins! ðŸ¤–";
          }
        } else {
          statusMessageElement.textContent = isPlayerTurn ? "Your Turn (X)" : "AI's Turn (O)";
        }
      };
      
      const renderBoard = () => {
        boardElement.innerHTML = '';
        board.forEach((value, index) => {
          const square = document.createElement('button');
          const isWinningSquare = winnerInfo.line?.includes(index);
          const textColor = value === 'X' ? playerXColor : playerOColor;

          square.className = `w-24 h-24 sm:w-28 sm:h-28 rounded-lg flex items-center justify-center text-5xl font-bold transition-colors duration-200 ${isWinningSquare ? winningStyle : baseStyle} ${!value && !isWinningSquare ? hoverStyle : ''}`;

          square.disabled = !!value || !gameActive;
          square.setAttribute('aria-label', `Square ${index} with value ${value || 'empty'}`);
          square.dataset.index = index;

          const span = document.createElement('span');
          span.textContent = value;
          span.className = textColor;
          
          square.appendChild(span);
          square.addEventListener('click', () => handleSquareClick(index));
          boardElement.appendChild(square);
        });
      };

      const checkForWinner = () => {
        const result = calculateWinner(board);
        if (result.winner) {
          winnerInfo = { winner: result.winner, line: result.line };
          gameActive = false;
        } else if (board.every(square => square !== null)) {
          winnerInfo = { winner: 'Draw', line: null };
          gameActive = false;
        }
        updateStatusMessage();
        renderBoard();
      };

      const aiMove = () => {
        if (!gameActive) return;

        const makeMove = (index) => {
          board[index] = 'O';
          isPlayerTurn = true;
          checkForWinner();
          if (gameActive) {
             updateStatusMessage();
             renderBoard();
          }
        };

        const emptySquares = board
          .map((val, index) => (val === null ? index : null))
          .filter((val) => val !== null);

        // Rule 1: Win if possible
        for (const move of emptySquares) {
          const tempBoard = [...board];
          tempBoard[move] = 'O';
          if (calculateWinner(tempBoard).winner === 'O') {
            makeMove(move);
            return;
          }
        }

        // Rule 2: Block player from winning
        for (const move of emptySquares) {
          const tempBoard = [...board];
          tempBoard[move] = 'X';
          if (calculateWinner(tempBoard).winner === 'X') {
            makeMove(move);
            return;
          }
        }

        // Rule 3: Take the center
        if (board[4] === null) {
          makeMove(4);
          return;
        }

        // Rule 4: Take an available corner
        const corners = [0, 2, 6, 8];
        const availableCorners = corners.filter(index => board[index] === null);
        if (availableCorners.length > 0) {
          const randomCorner = availableCorners[Math.floor(Math.random() * availableCorners.length)];
          makeMove(randomCorner);
          return;
        }

        // Rule 5: Take an available side
        const sides = [1, 3, 5, 7];
        const availableSides = sides.filter(index => board[index] === null);
        if (availableSides.length > 0) {
            const randomSide = availableSides[Math.floor(Math.random() * availableSides.length)];
            makeMove(randomSide);
            return;
        }
      };

      const handleSquareClick = (index) => {
        if (!gameActive || !isPlayerTurn || board[index]) {
          return;
        }

        board[index] = 'X';
        isPlayerTurn = false;
        renderBoard();
        checkForWinner();

        if (gameActive) {
          updateStatusMessage();
          setTimeout(aiMove, 700);
        }
      };
      
      const resetGame = () => {
        board = Array(9).fill(null);
        isPlayerTurn = true;
        winnerInfo = { winner: null, line: null };
        gameActive = true;
        updateStatusMessage();
        renderBoard();
      };

      resetButton.addEventListener('click', resetGame);
      
      // Initial game setup
      resetGame();
    });
  </script>
</body>
</html>
